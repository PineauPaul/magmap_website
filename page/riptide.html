<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
         <link rel="stylesheet"  href="../css/css.css"/>
        
        <title>MagMap Project : Riptide</title>
    </head>

    <body>

        <header>
                <div id="titre_principal">
                    <div id="logo">
                        <img src="../picture/ensta.png" alt="Logo de l'ensta" />
                           
                    </div>
                    <div id="title_header">
                    <h1><a href="../index.html">  Project Magmap </a></h1>
                </div>
                </div>
                
                <nav>
                    <ul>
                    	<li> <a href="magnetic.html"> Etude du capteur magnétique </a></li>
                        <li> <a href="saturne.html"> Saturne </a></li>

                    </ul>
                </nav>
            </header>
        
        <div id="page_title">
        <h1>Prise en main du Ritpide pour créer la carte électromagnétique sous-marine</h1>
        </div>

        <div id="intro">
        	<h3>Présentation du projet:</h3>
        
	        <p>
	        	Pour ce projet, nous nous sommes divisés en sous-groupe afin de travailler à la fois sur la partie riptide, capteur magnétique et saturne. Cette page concerne le travail réalisé sur l’AUV. 
	        	Les membres ayant travaillés sur cette partie sont :

	        </p>

	        <p> FLÉCHARD Romane         </p>
	        <p> HACENE Hamid            </p>
	        <p> KASSAMALY Mourtaza      </p>
	        <p> LEMOINE Corentin        </p>
	        <p> PINEAU Paul             </p>
	        <p> PIRANDA Julien          </p>
	        <p> VINTRAS Quentin         </p>

	        <p>
	        	Nous avons divisé nos travaux en 3 grandes parties : 
	        </p>
        </div>

        <button class="collapsible">1. Contrôleur</button>
        <div class="content">
    		<p> Fait le 16/11/2020    </p>
	    		<p> Prise en main du code existant et passage sous python3  </p>
	    		<p> Contrôleur python avec suivi d’une liste de waypoints en partie sous ROS  </p>

	    	<p> Fait le 25/11/2020  </p>
	    		<p> Aujourd’hui nous avons avancé le passage sous ROS du contrôleur en respectant l’architecture déjà existante. Nous avons fait face à plusieurs problèmes sur la mise en œuvre de certains publishers. On prévoit maintenant de faire un observateur d’état en utilisant les données sous ROS avant de les renvoyer au contrôleur.  </p>

	    	<p> Fait le 14/12/2020  </p>
	    		<p>  Aujourd'hui, nous avons continué le passage sous ROS du riptide. Nous nous sommes occupés de la partie mission du projet. Avec la mise en place de waypoints, de lecture de fichier Json. Le nœud Ros Mission permet d’envoyer les waypoints sous la forme de geometry_msgs/Points. De plus, nous nous sommes intéressés au traitement des données reçues par les capteurs.  </p>

	    	<p> Fait le 06/01/2021  </p>
	    		<p> Mise en commun des travaux avec l’ensemble des sous-groupes du projet Riptide.  </p>
	    		<p> Etude et bilan de la partie simulation.  </p>
	    		<p> Recherche et adaptation de la partie ROS avec la partie Gazebo: la simulation demandant en entrée les différentes consignes des moteurs, nous avons adapté la partie ROS pour publier les bonnes informations nécessaires au bon fonctionnement de la simulation.  </p>
                <img src="../picture/schema_noeuds_ros.png">
	    		<p> Une fois, la partie ROS finie. Nous avons travaillé sur un moyen de lancer les nœuds ROS plus facilement. Pour cela, nous avons mise en place un fichier launch. Problèmes rencontrés lors de la mise en place de ce fichier dû à un caractère de fin de ligne Windows qui posait problème pour Linux  </p>
	    		<p> Le fichier launch permet donc de lancer les différents nœuds ROS et prend en argument le chemin du fichier json (qui décrit la mission). </p>
        </div>
        <button class="collapsible">2. Simulation Gazebo –UUV Simulator</button>
        <div class="content">
          <p> Fait le 16/11/2020  </p>
                <p> Simulation d’un AUV quelconque sur Gazebo  </p>
                <p> Ajout de capteurs sur Gazebo  </p>
                <p> Ajout de thrusters sur Gazebo  </p>
                <p> Modélisation 3D du Riptide (corps et ailerons) sur CAO.   </p>

            <p> Fait le 25/11/2020  </p>
                <p> Cette semaine nous nous sommes focalisés sur la création d’un AUV pour le plugin UUV Simulator de Gazebo. Cela comprend l’analyse des besoins d’informations sur le Riptide aussi bien sur la partie mécanique (matrice d’inertie, volume, masse) que sur la partie capteurs/actionneurs qu’il va falloir modéliser. Cela nécessite pour nous une revue des possibilités de Gazebo et du plugin UUV Simulator pour savoir comment implémenter les capteurs et actionneurs ainsi que les informations nécessaires au simulateur.  </p>

                <p> Apprentissage de Gazebo et de ses possibilités <hr> </p>
                <p> Prise en main de Gazebo et UUV Simulator  </p>
                <p> Notion de fichiers .world, .urdf, .xacro...  </p>
                <p> Réalisations de tutoriels pour apprendre à utiliser le logiciel  </p>
                <p> Etude du logiciel en essayant ses fonctions  </p>
                
                <p> Plugins pour les capteurs et pour les actionneurs  </p>
                <p> Découverte et choix des plugins modélisant les actionneurs  </p>
                <p> Découverte et choix des plugins modélisant les actionneurs  </p>
                <p> Comment les implémenter sur un AUV et les utiliser ?  </p>
                <p> Commande actionneur ?  </p>
                <p> Retour capteur ?  </p>

                <h1> Lancement de la modélisation du Riptide sur Gazebo  </h1>
                <p> Nous avons commencé par la modélisation 3Ddu robot qui comprend le corps, les ailerons et le propulseur.  </p>
                <img src="../picture/riptide0.png">
                <img src="../picture/aile_riptide.png">
                <p> En parallèle nous avons créé le plugin du Riptidesur gazebo. Il comprend les liens vers les actionneurs, les capteurs, mais aussi le modèle physique (masses, matrice d’inertie, modèle hydrodynamique...). Nous avons implémenté le modèle 3D dans le plugin, il faut maintenant synchroniser les actionneurs et les capteurs avec ce modèle 3D.  </p>
                <img src="../picture/riptide_gazebo0.png">

            <p> Fait le 14/12/2020  </p>
                <p> Finir la modélisation du Riptide (positions relatives et commande du propulseur et des ailerons)  </p>
                <img src="../picture/riptide_gazebo1.png">

            <p> Fait le 06/01/2021  </p>
                <p> Modélisation finale du Riptide : ajout des ailerons et des capteurs.  </p>
                <img src="../picture/riptide_gazebo2.png">
                <p> Gestion de la flottaison du Riptide :  </p>
                <p> A l’aide du principe  d’Archimède, nous avons calculé la masse du Riptide dans le cas où celui ci est en équilibre dans l’eau. Ainsi nous avons pu déterminer la masse du Riptide à rentrer dans gazebo afin que celui-ci flotte.  </p>


                <p> Test de commande du Riptide sous Rqt:  </p>
                     <p> Envoi de commande (directement sur les topics via Rqt) au propulseur et aux ailerons.  </p>
                     <p> Vérification de la manœuvrabilité de l’AUV.  </p>
                <p> Point avec Paul et Julien pour se mettre d’accord sur les topics utilisés et la forme des messages que l’on se transmettra mutuellement entre notre simulation Gazebo et leur contrôleur sous ROS.  </p>

        </div>
        <button class="collapsible">3. Partie électronique</button>
        <div class="content">
          <p> Fait le 16/11/2020  </p>
                <p>   </p>
                <img src="../picture/schema_elec.png">
                
                <p> Architecture matérielle :  </p>
                <p> Pour effectuer des tests sur la partie matérielle, nous allons ajouter une télécommande pour piloter le robot. Comme les récepteurs ne nous permettent pas d’avoir suffisamment de voies pour contrôler l’ensemble des actionneurs (+sélecteur), nous allons rajouter une arduino (pour utiliser les 12 voies du PPM). Ceci a l’avantage de permettre un contrôle plus facile et intuitif pour commander le Riptide en nous permettant de mixer plus facilement les voies. Pour démarrer/arrêter le système, nous partons sur un interrupteur magnétique ILS.  </p>

                <p> Commande du matériel :  </p>
                <p> mail envoyé à M. Le Bars et M. Fourniol  </p>

            <p> Fait le 25/11/2020  </p>
                <p> Réflexion sur la mise en place d’une interface haut niveau (interface web) en node js qui sera liée au contrôleur ROS dans le but de suivre l’état de l’AUV à distance et de lui envoyer des waypoints.
                  </p>
                <p> Changement du capteur de pression (illustration ci-dessous):   </p>
                    <p> Détachement de l’ancien capteur  </p>
                    <p> Fraisage d’un trou pour le nouveau capteur dans la coque de l’AUV  </p>
                    <p> Insertion du capteur bar30 de BlueRobotics  </p>
                    <p> Test de l’étanchéité du capteur.  </p>
                    <img src="../picture/photo_riptide0.png">
                <p> De plus nous avons travaillez sur l’implémentation d’un code permettant la reprise à distance de l’AUV via une télécommande.  </p>

            <p> Fait le 06/01/2021  </p>
                <p> Test du capteur de pression :   </p>
                    <p> Soudure des câbles sur les connecteurs  </p>
                    <p> Intégration sur le bus I2C de la raspberry pi 4 du Riptide  </p>
                    <p> Installation de la librairie ‘’ms5837-python’’  </p>
                    <p> Lecture des données du capteur  </p>
                    <img src="../picture/photo_riptide1.png">
        </div>
  



   


    <script>
        var coll = document.getElementsByClassName("collapsible");
        var i;

        for (i = 0; i < coll.length; i++) {
          coll[i].addEventListener("click", function() {
            this.classList.toggle("active");
            var content = this.nextElementSibling;
            if (content.style.maxHeight){
              content.style.maxHeight = null;
            } else {
              content.style.maxHeight = content.scrollHeight + "px";
            } 
          });
        }
    </script>




    </body>
</html>